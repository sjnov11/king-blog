 
<div class="post-header">
  <h1 class="post-title">Josephus Problem</h1>
  <div class="post-date">2018-06-18</div>
  <div class="post-tags">
    <a class="post-tag">algorithm</a>
  </div>
</div>

<hr class="hr-small">
<div class="body">
<p>Josephus Problem은 유대 역사가 Josephus 의 이야기에서 유래되었다고 합니다. 당시 유대인 지도자 Josephus와 그의 추종자들은 로마의 지배에 맞서 싸웠지만, 위기에 처하자 동굴로 숨어들어 명예롭게 자결하기로 결정합니다.</p>
<blockquote>
<p><em>“Josephus 와 그의 병사 총 41명은 원형으로 둘러 앉아 남은 사람이 없을 때 까지 세번째 사람마다 죽이기로 했다. Joshphus는 막상 죽음에 직면하자 살고싶은 마음에서 마지막에 살아남을 수 있는 자리를 찾아내, 살아남은 다음 로마병사들에게 항복했다고 한다.”</em></p>
</blockquote>
<h2 id="문제-해결">문제 해결</h2>
<p>이 문제를 간단히 바꾼다면 다음과 같습니다.</p>
<p><strong><em>n명의 사람이 원형으로 둘러앉아 있고, k번째 사람이 죽임을 당한다. 이 때, 마지막까지 살아남을 수 있는 사람의 index 를 구하여라</em>.</strong></p>
<p>문제의 해는 <em>n</em>명의 사람이 있을 때와 한 명이 죽임을 당하고 난 <em>n-1</em>명의 사람이 있을 때를 비교하여, 점화식을 세우면 쉽게 해결할 수 있습니다.</p>
<figure>
<img src="https://github.com/sjnov11/sjnov11.github.com/blob/master/_img/2018/06/17/josephus_1.JPG?raw=true" alt="왼쪽 n=6일 때, 오른쪽 n=5 일 때의 모습" /><figcaption>왼쪽 n=6일 때, 오른쪽 n=5 일 때의 모습</figcaption>
</figure>
<p><em>n</em> 과 <em>k</em> 가 주어졌을 때, 마지막에 살아남는 사람의 <em>index</em> 를 <em>Josephus(n, k)</em> 라고 합시다. 위의 그림에서 <em>n=6</em> 이고 <em>k=3</em> 입니다. 처음 <em>k</em>번째 사람을 죽이고 나서의 모습은 우측 그림과 같습니다. 여기서 다시 count 하는 시작점을 0으로 두게 된다면, 빨간색 숫자의 경우에서 마지막으로 살아남는 사람의 <em>index</em>는 <em>Josephus(n-1, k)</em> 가 됩니다. 즉, <em>n=5</em> 인 경우의 마지막으로 살아남는 사람의 <em>index</em> 에서, <em>n=6</em>에서 이동한 만큼을 더해주면(이 경우 k=3) 답을 쉽게 구할 수 있습니다.</p>
<p><span class="math display">\[
Josephus(n, k) = (Josephus(n-1, k) + k) \ mod\  n \\
Josephus(1,k) = 0
\]</span> <em>n=1</em> 일 때는 마지막 사람만이 존재하므로 <em>index = 0</em> 이며, <em>k</em>만큼 더해주었을 때 <em>n</em>보다 클 경우는 circular 형태이므로 모듈러 연산을 통해 그 위치를 찾습니다.</p>
<p>이 알고리즘은 순차적으로 한번씩 연산을 하므로 <span class="math inline">\(O(n)\)</span>이 됩니다.</p>
<h2 id="문제">문제</h2>
<p><a href="https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWNcL9nKpbEDFAV8"><strong>문제 #4411 덕환이의 카드뽑기</strong></a></p>
<p><em>Josephus</em> 문제를 이용해서 푼다면 매우 쉽게 해결할 수 있습니다. 이 때, <em>n</em>의 숫자와 <em>k</em>의 숫자가 매우 크므로, top-down 방식으로는 stack overflow가 발생할 수 있으므로, bottom-up 방식으로 해결했습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="dt">long</span> <span class="dt">long</span> josephus(<span class="dt">long</span> <span class="dt">long</span> n, <span class="dt">long</span> <span class="dt">long</span> k) {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="co">//if (n == 1) {</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="co">//  return 0;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="co">//}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="co">////cout &lt;&lt; &quot;n: &quot; &lt;&lt; n &lt;&lt; &quot;/ k: &quot; &lt;&lt; k &lt;&lt; endl;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="co">//return (josephus(n - 1, k) + (k + 1)) % n;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    </a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="dt">long</span> <span class="dt">long</span> result = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="cf">for</span> (<span class="dt">long</span> <span class="dt">long</span> i = <span class="dv">2</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">        result = (result + (k + <span class="dv">1</span>)) % i;</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv)</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">{</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">    <span class="dt">int</span> test_case;</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    <span class="dt">int</span> T;</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    </a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    cin &gt;&gt; T;</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28"><span class="co">    여러 개의 테스트 케이스가 주어지므로, 각각을 처리합니다.</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29"><span class="co">    */</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30">    <span class="cf">for</span> (test_case = <span class="dv">1</span>; test_case &lt;= T; ++test_case)</a>
<a class="sourceLine" id="cb1-31" data-line-number="31">    {</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">        <span class="dt">long</span> <span class="dt">long</span> N, K;</a>
<a class="sourceLine" id="cb1-33" data-line-number="33">        cin &gt;&gt; N &gt;&gt; K;</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">        cout &lt;&lt; <span class="st">&quot;#&quot;</span> &lt;&lt; test_case &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; (josephus(N, K) + <span class="dv">1</span>) % (N + <span class="dv">1</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb1-36" data-line-number="36"></a>
<a class="sourceLine" id="cb1-37" data-line-number="37">    <span class="cf">return</span> <span class="dv">0</span>;<span class="co">//정상종료시 반드시 0을 리턴해야합니다.</span></a>
<a class="sourceLine" id="cb1-38" data-line-number="38">}</a></code></pre></div>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="www.geeksforgeeks.org/josephus-problem-set-1-a-on-solution"><strong>GeekforGeeks</strong></a></li>
</ul> 
</div>



